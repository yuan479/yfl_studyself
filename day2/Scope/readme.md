# 作用域

  ## 作用域嵌套
  ### 定义:
  作用域嵌套是指一个作用域嵌套在另一个作用域内部的情况。当内层作用域无法访问某个变量时，会沿着“作用域链”向上查找，直到找到该变量或抵达全局作用域。这种机制确保了变量的正确访问路径。
  ### 作用域链
  作用域链是一个查找变量的路径，由当前作用域和所有外层作用域组成。查找变量时，引擎会从最内层作用域开始，逐级向外查找。
  ### 示例
  ```js
  function f1(a) {
      var b = 2;
      f2();
      function f2() {
          var c = 3;
          console.log(a + b + c); // 输出 6 (1 + 2 + 3)
      }
  }
  var a = 1;
  f1(a);
  ```
  ### 分析
  当 console.log(a + b + c) 执行时，需要查找变量 a、b 和 c 的值：
  1. 从 f2 的作用域开始查找 c。
  2. 从 f2 的作用域继续向上查找，在f1中查找得到 b。
  3. 从 f1 的作用域再继续向上查找，最终找到全局作用域中的变量 a。
 
  作用域链的动态性：
  作用域链在函数定义时确定（词法作用域），而不是调用时。即使 f2 被调用时脱离了 f1 的上下文，它仍然能访问 f1 中的变量。
  
  ## 词法作用域
  ### 定义：
  词法作用域，也称为静态作用域，是指变量的作用域由代码的书写位置决定，而非函数调用时的执行上下文。词法作用域在代码编写时就已经确定，与运行时无关。
  ### 特点
  变量的查找路径由函数定义的位置决定。
  嵌套函数可以访问外层函数的变量（即“闭包”）。
  ### 示例
  ```js
  function f1() {
      var x = 10;
      function f2() {
          console.log(x); // 输出 10
      }
      f2();
  }
  f1();
  ```
  ### 分析
  f2 函数在 f1 内部定义，因此它的作用域链包含 f1 的作用域。
  当 f2 被调用时，它可以直接访问 f1 中的变量 x，即使 f1 已经执行完毕（这是闭包的体现）。
  ### 
  ```js
  function f1() {
      var x = 10; // 定义于 f1 函数作用域
      f2(); // 调用外部定义的 f2 函数
  }

  function f2() {
      console.log(x); // 报错: x is not defined
  }
  f1(); // 报错
  ```

  ## 函数作用域
  ### 定义
  函数作用域是指在函数内部声明的变量或参数仅在该函数内部有效。函数作用域是JavaScript中默认的作用域类型（在ES6之前）。
  ### 特点
  使用 var 声明的变量具有函数作用域。
  变量在函数内部定义，无法从外部访问。
  变量提升（Hoisting）：函数作用域中的变量声明会被提升到函数顶部。
  ### 示例
  ```js
  function f1() {
      var a = 1; // 函数作用域
      if (true) {
          var b = 2; // 实际上也是函数作用域
      }
      console.log(a); // 1
      console.log(b); // 2（尽管在 if 块中定义，但作用域是函数）
  }
  f1();
  console.log(a); // 报错：a is not defined
  console.log(b); // 报错：b is not defined
  ```
  ### 分析
  a 和 b 都是函数作用域的变量，即使 b 在 if 块中定义，但由于 var 的作用域规则，b 实际上属于整个 f1 函数。
  外部无法访问函数内部的变量，因此 console.log(a) 和 console.log(b) 在函数外部会报错。

  ## 块级作用域
  ### 定义:
  块级作用域是指变量的作用域限制在代码块（由 {} 包裹的代码段）内部。在ES6中，通过 let 和 const 关键字引入了块级作用域。

  ### 特点
  使用 let 或 const 声明的变量具有块级作用域。
  块级作用域适用于 if、for、while 等代码块。
  变量不会被提升到块的顶部（与 var 不同）。
  ### 示例
  ```js
  {
      let x = 10; // 块级作用域
      const y = 20; // 块级作用域
      var z = 30; // 函数作用域（如果在函数内部）或全局作用域
  }
  console.log(x); // 报错：x is not defined
  console.log(y); // 报错：y is not defined
  console.log(z); // 30（如果在全局作用域中）
  ```
  ### 分析
  x 和 y 是块级作用域的变量，仅在 {} 内部有效。
  z 是 var 声明的变量，其作用域是函数或全局作用域，因此可以在块外部访问。
  块级作用域 vs 函数作用域
  ### var 的问题：
```js
  for (var i = 0; i < 3; i++) {
      setTimeout(function() {
          console.log(i); // 输出 3, 3, 3
      }, 1000);
  }
  ```
  ### 分析
  由于 var 的函数作用域，i 在循环结束后仍为 3，导致所有回调函数输出 3。
  let 的解决方案：
 ```js
  for (let i = 0; i < 3; i++) {
      setTimeout(function() {
          console.log(i); // 输出 0, 1, 2
      }, 1000);
  }
  ```
  let 的块级作用域确保每次循环迭代的 i 是独立的，因此输出 0, 1, 2。